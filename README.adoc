== Django container usage
To build a container with a specific Django version modify `requirements.txt` in the project directory.

You can also build the container using a different directory entirely where you can have your own `requirements.txt`:

-------
$ docker build --build-arg PROJECT_DIR=<path-to-your-dir> . -t <name:tag>
-------

== Running the app
First, run the database container:

-------
$ docker run -d --name postgres -e POSTGRES_USER=django -e POSTGRES_PASSWORD_FILE=/opt/postgres_pass -v $(pwd)/postgres_pass:/opt/postgres_pass -v <dir-to-store-pgdata>:/var/lib/postgresql/data postgres:10
-------
To run the app, first create a container off of the newly built image by running:

-------
$ docker run --name app -dit -p 8000:8000 $(pwd):/opt/app --link postgres:db <name:tag> /bin/bash
-------
When inside the container, move to the directory with the app and run the dev server:

-------
# cd /opt/app/podcastmanager/
# python manage.py runserver 0.0.0.0:8000
-------

=== Web server proxy
Instead of using Django's dev server, you can use nginx to proxy request to the app run with gunicorn.

Launch an nginx container and link it to the app container:

-------
$ docker run -d --name web -p 80:80 -v $(pwd)/nginx.conf:/etc/nginx/conf.d/default.conf:ro -v $(pwd)/podcastmanager/static/:/usr/share/nginx/html/static/:ro --link app:app nginx:1.15
-------
Inside the app container first collect static files:

-------
# cd /opt/app/podcastmanager/
# python manage.py collectstatic
-------
then run `gunicorn`:

-------
# gunicorn podcastmanager.wsgi -b 0.0.0.0:8000
-------
API will now be available under http://localhost/.

Bear in mind that nginx container is responsible for serving static files, so they won't be available when contacting the app container through its exposed port.

[NOTE]
====
The Docker image with for the app has supervisor configured to run gunicorn inside, so instead of running the container interactively, you can just let it use its default entrypoint command by executing:

-------
$ docker run --name app -d $(pwd):/opt/app --link postgres:db <name:tag>
-------
====

== CI/CD
To build Jenkins image with plugins backed into it, run:

-------
$ docker build . -f Dockerfile.jenkins -t <name:tag>
-------
Run the Jenkins container with:

-------
$ docker run -d --name jenkins -p 8080:8080 -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker -v <host-dir-for-jenkins-home>:/var/jenkins_home <name:tag>
-------
Now you can use Docker on the host from inside the Jenkins container.

=== Adding Jenkins plugins
To install a new Jenkins plugin, add its short name to the `plugins.txt` file, then build the Jenkins image and run a temporary container:

-------
$ docker run --rm <name:tag>
-------
If the plugin has prerequisites, they'll be listed on the output. Simply add the requirement to the list of plugins and rebuild the image.

== API Reference

-------
GET /v1/podcasts
-------
Retrieves a list of all podcasts.

Add `?format=json` or `.json` at the end to get output formatted in JSON.


-------
POST /v1/podcasts
{
    "name": "A podcast",
    "url": "http://example.com"
}
-------
Adds a podcast.

Parameters:

* *name* (required) - the name of the podcast
* *url* (required) - URL of this podcast's feed
